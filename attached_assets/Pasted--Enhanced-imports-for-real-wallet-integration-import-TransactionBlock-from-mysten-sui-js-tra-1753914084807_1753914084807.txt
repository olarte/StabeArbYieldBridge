// Enhanced imports for real wallet integration
import { TransactionBlock } from '@mysten/sui.js/transactions';
import { Ed25519Keypair } from '@mysten/sui.js/keypairs/ed25519';
import { fromB64 } from '@mysten/sui.js/utils';

// Store active wallet connections
const walletConnections = new Map();

// Register wallet connection from frontend
app.post('/api/wallet/register', async (req, res) => {
  try {
    const { 
      sessionId, 
      evmAddress, 
      suiAddress, 
      evmChainId, 
      suiNetwork = 'devnet' 
    } = req.body;

    if (!sessionId || (!evmAddress && !suiAddress)) {
      return res.status(400).json({
        success: false,
        error: 'Missing required wallet information'
      });
    }

    walletConnections.set(sessionId, {
      evmAddress,
      suiAddress,
      evmChainId,
      suiNetwork,
      registeredAt: new Date().toISOString()
    });

    console.log(`üìù Registered wallet session: ${sessionId}`);
    console.log(`  EVM: ${evmAddress} (Chain: ${evmChainId})`);
    console.log(`  Sui: ${suiAddress} (Network: ${suiNetwork})`);

    res.json({
      success: true,
      data: {
        sessionId,
        registeredWallets: {
          evm: !!evmAddress,
          sui: !!suiAddress
        }
      }
    });

  } catch (error) {
    console.error('Wallet registration error:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to register wallet'
    });
  }
});

// Enhanced bidirectional swap with real wallet integration
app.post('/api/swap/bidirectional-real', async (req, res) => {
  try {
    const {
      fromChain,
      toChain,
      fromToken,
      toToken,
      amount,
      sessionId, // Frontend provides this
      minSpread = 0.5,
      maxSlippage = 1,
      enableAtomicSwap = true,
      timeoutMinutes = 60,
      bypassPegProtection = false
    } = req.body;

    // Validate wallet session
    const walletSession = walletConnections.get(sessionId);
    if (!walletSession) {
      return res.status(400).json({
        success: false,
        error: 'Wallet session not found. Please connect your wallets first.',
        suggestion: 'Call /api/wallet/register first'
      });
    }

    // Validate wallet addresses for swap direction
    if (fromChain === 'celo' && !walletSession.evmAddress) {
      return res.status(400).json({
        success: false,
        error: 'EVM wallet required for Celo transactions'
      });
    }

    if (toChain === 'sui' && !walletSession.suiAddress) {
      return res.status(400).json({
        success: false,
        error: 'Sui wallet required for Sui transactions'
      });
    }

    // Validate supported chain pairs
    const supportedPairs = [
      { from: 'celo', to: 'sui', via: 'ethereum' },
      { from: 'sui', to: 'celo', via: 'ethereum' }
    ];

    const swapPair = supportedPairs.find(p => p.from === fromChain && p.to === toChain);
    if (!swapPair) {
      return res.status(400).json({
        success: false,
        error: 'Unsupported swap direction',
        supportedPairs: supportedPairs.map(p => `${p.from} ‚Üí ${p.to}`)
      });
    }

    // Enhanced peg protection validation
    if (!bypassPegProtection) {
      console.log('üõ°Ô∏è Validating swap against peg protection...');
      const pegValidation = await validateSwapAgainstPegProtection(fromChain, toChain, fromToken, toToken);
      
      if (!pegValidation.safe) {
        return res.status(423).json({
          success: false,
          error: 'Swap blocked by peg protection',
          pegValidation,
          suggestion: 'Wait for peg stabilization or contact admin'
        });
      }
    }

    // Generate atomic swap components
    const swapId = `real_swap_${Date.now()}_${randomBytes(8).toString('hex')}`;
    const secret = randomBytes(32);
    const hashlock = createHash('sha256').update(secret).digest('hex');
    const timelock = Math.floor(Date.now() / 1000) + (timeoutMinutes * 60);

    // Initialize enhanced swap state with wallet info
    const swapState = new SwapState({
      swapId,
      fromChain,
      toChain,
      fromToken,
      toToken,
      amount,
      walletSession, // Store wallet session
      minSpread,
      maxSlippage,
      enableAtomicSwap,
      hashlock,
      secret: secret.toString('hex'),
      timelock
    });

    // Perform initial spread check
    console.log(`üîç Checking cross-chain spread for ${fromChain} ‚Üí ${toChain}`);
    const spreadCheck = await checkCrossChainSpread(fromChain, toChain, fromToken, toToken, minSpread);
    
    if (!spreadCheck.meetsThreshold) {
      return res.status(400).json({
        success: false,
        error: `Insufficient spread: ${spreadCheck.spread}% < ${minSpread}%`,
        spreadCheck,
        suggestion: `Wait for spread ‚â• ${minSpread}% or lower minSpread parameter`
      });
    }

    swapState.spreadCheck = spreadCheck;

    // Create comprehensive execution plan with real wallet integration
    const executionPlan = {
      type: 'BIDIRECTIONAL_ATOMIC_SWAP_WITH_WALLETS',
      route: `${fromChain.toUpperCase()} ‚Üí ${swapPair.via.toUpperCase()} ‚Üí ${toChain.toUpperCase()}`,
      wallets: {
        fromChain: fromChain === 'celo' ? walletSession.evmAddress : walletSession.suiAddress,
        toChain: toChain === 'celo' ? walletSession.evmAddress : walletSession.suiAddress,
        bridgeChain: walletSession.evmAddress // Always use EVM for bridging
      },
      steps: [
        {
          type: 'WALLET_VERIFICATION',
          description: 'Verify wallet balances and approvals',
          chain: fromChain,
          status: 'PENDING'
        },
        {
          type: 'TOKEN_APPROVAL',
          description: `Approve ${fromToken} spending on ${fromChain}`,
          chain: fromChain,
          status: 'PENDING',
          requiresSignature: true
        },
        {
          type: 'FUSION_SWAP_SOURCE',
          description: `Swap ${fromToken} ‚Üí bridge token via 1Inch Fusion+`,
          chain: fromChain,
          dex: fromChain === 'celo' ? 'uniswap_v3' : 'cetus',
          status: 'PENDING',
          requiresSignature: true
        },
        {
          type: 'BRIDGE_INITIATE',
          description: `Bridge tokens from ${fromChain} to ${toChain}`,
          chain: 'ethereum',
          status: 'PENDING',
          requiresSignature: true
        },
        {
          type: 'BRIDGE_CLAIM',
          description: `Claim bridged tokens on ${toChain}`,
          chain: toChain,
          status: 'PENDING',
          requiresSignature: true
        },
        {
          type: 'FUSION_SWAP_DEST',
          description: `Swap bridge token ‚Üí ${toToken} via 1Inch Fusion+`,
          chain: toChain,
          dex: toChain === 'celo' ? 'uniswap_v3' : 'cetus',
          status: 'PENDING',
          requiresSignature: true
        }
      ],
      estimatedGas: {
        [fromChain]: fromChain === 'celo' ? '0.02 CELO' : '0.002 SUI',
        [toChain]: toChain === 'celo' ? '0.02 CELO' : '0.002 SUI',
        bridge: '0.08 ETH'
      },
      estimatedTime: '20-60 minutes',
      estimatedFees: {
        dexFees: '0.3-0.6%',
        bridgeFees: '0.1%',
        gasFees: '$5-15',
        totalFees: '~1-2%'
      }
    };

    swapState.executionPlan = executionPlan;
    swapState.updateStatus('PLAN_CREATED');

    // Store swap state
    swapStates.set(swapId, swapState);

    console.log(`‚úÖ Created real wallet swap: ${swapId}`);
    console.log(`  From: ${walletSession.evmAddress || walletSession.suiAddress}`);
    console.log(`  Spread: ${spreadCheck.spread}%`);

    res.json({
      success: true,
      data: {
        swapId,
        executionPlan,
        spreadCheck,
        walletInfo: {
          fromWallet: executionPlan.wallets.fromChain,
          toWallet: executionPlan.wallets.toChain,
          signaturesRequired: executionPlan.steps.filter(s => s.requiresSignature).length
        },
        estimatedProfit: spreadCheck.profitEstimate,
        nextStep: 'Execute swap using /api/swap/execute-real endpoint'
      }
    });

  } catch (error) {
    console.error('Real wallet swap creation error:', error.message);
    res.status(500).json({
      success: false,
      error: 'Failed to create wallet-integrated swap',
      details: error.message
    });
  }
});