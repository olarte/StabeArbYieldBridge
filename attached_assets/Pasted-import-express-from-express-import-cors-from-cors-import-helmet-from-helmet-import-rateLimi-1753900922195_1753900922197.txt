import express from 'express';
import cors from 'cors';
import helmet from 'helmet';
import rateLimit from 'express-rate-limit';
import { ethers } from 'ethers';
// import { FusionSDK, LimitOrderProtocolV4 } from '@1inch/fusion-sdk';
import { randomBytes, createHash } from 'crypto';
import { SuiClient, getFullnodeUrl } from '@mysten/sui.js/client';
import { TransactionBlock } from '@mysten/sui.js/transactions';
// import { ContractKit } from '@celo/contractkit';
import axios from 'axios';
import dotenv from 'dotenv';

dotenv.config();

const app = express();
const PORT = process.env.PORT || 5000;

// Middleware
app.use(helmet());
app.use(cors());
app.use(express.json());

// Rate limiting
const limiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 100 // limit each IP to 100 requests per windowMs
});
app.use('/api/', limiter);

// Chain configurations with Uniswap V3 integration
const CHAIN_CONFIG = {
  ethereum: {
    rpc: process.env.ETHEREUM_RPC || 'https://eth.llamarpc.com',
    chainId: 1,
    tokens: {
      USDC: '0xA0b86a33E6441efC4b5e9fE1D7EC8c4D8a3b8d2E',
      USDT: '0xdAC17F958D2ee523a2206206994597C13D831ec7'
    }
  },
  celo: {
    rpc: process.env.CELO_RPC || 'https://alfajores-forno.celo-testnet.org',
    chainId: 44787, // Alfajores testnet
    tokens: {
      cUSD: '0x874069Fa1Eb16D44d622F2e0Ca25eeA172369bC1', // Alfajores cUSD
      USDC: '0x2F25deB3848C207fc8E0c34035B3Ba7fC157602B', // Alfajores USDC
      CELO: '0xF194afDf50B03e69Bd7D057c1Aa9e10c9954E4C9'  // Alfajores CELO
    },
    // Real Uniswap V3 addresses on Celo Alfajores testnet
    uniswap: {
      factory: '0x229Fd76DA9062C1a10eb4193768E192bdEA99572',      // UniswapV3Factory
      router: '0x8C456F41A3883bA0ba99f810F7A2Da54D9Ea3EF0',       // SwapRouter02
      quoter: '0x3c1FCF8D6f3A579E98F4AE75EB0adA6de70f5673',       // QuoterV2
      nftManager: '0x3d79EdAaBC0EaB6F08ED885C05Fc0B014290D95A',    // NonfungiblePositionManager
      universalRouter: '0x84904B9E85F76a421223565be7b596d7d9A8b8Ce'  // UniversalRouter
    },
    // Mainnet addresses (for reference)
    uniswapMainnet: {
      factory: '0xAfE208a311B21f13EF87E33A90049fC17A7acDEc',      // UniswapV3Factory  
      router: '0x5615CDAb10dc425a742d643d949a7F474C01abc4',       // SwapRouter02
      quoter: '0x82825d0554fA07f7FC52Ab63c961F330fdEFa8E8',       // QuoterV2
      nftManager: '0x3d79EdAaBC0EaB6F08ED885C05Fc0B014290D95A',    // NonfungiblePositionManager
      universalRouter: '0x643770E279d5D0733F21d6DC03A8efbABf3255B4'  // UniversalRouter
    }
  },
  sui: {
    rpc: process.env.SUI_RPC || getFullnodeUrl('devnet'), // Use Sui Devnet
    chainId: 'sui:devnet',
    tokens: {
      USDC: '0x5d4b302506645c37ff133b98c4b50a5ae14841659738d6d733d59d0d217a93bf::coin::COIN', // Sui USDC
      USDY: '0xa3d3b6c6d5e9c8f4b7d8e5f2a1c3e9d8f5b2c9e8d5f2a1c3e8d5f2a1c3e9d8f5::usdy::USDY', // Mock USDY
      SUI: '0x2::sui::SUI' // Native SUI token
    },
    // Cetus DEX integration on Sui Devnet
    cetus: {
      packageId: '0x1eabed72c53feb3805120a081dc15963c204dc8d091542592abaf7a35689b2fb', // Cetus package ID
      globalConfig: '0xdaa46292632c3c4d8f31f23ea0f9b36a28ff3677e9684980e4438403a67a3d8f', // Cetus global config
      pools: {
        // USDC/USDY pool configuration
        'USDC-USDY': {
          poolId: '0x123...', // Will be detected dynamically
          tickSpacing: 2,
          feeRate: 500 // 0.05%
        }
      }
    }
  }
}

async function initializeCetusContracts() {
  const suiConfig = CHAIN_CONFIG.sui.cetus;
  
  try {
    console.log('ðŸŒŠ Initializing Cetus DEX contracts on Sui Devnet...');
    
    // Test Sui connection
    const chainId = await suiProvider.getChainIdentifier();
    console.log(`ðŸ§ª Testing Sui connection: ${chainId}`);
    
    // Check if Cetus package exists
    try {
      const packageInfo = await suiProvider.getObject({
        id: suiConfig.packageId,
        options: { showContent: true }
      });
      
      if (packageInfo.data) {
        console.log('âœ… Cetus package found on Sui Devnet');
      }
    } catch (packageError) {
      console.log('âš ï¸ Cetus package not found, using mock configuration');
    }
    
    // Initialize Cetus client configuration
    cetusContracts = {
      packageId: suiConfig.packageId,
      globalConfig: suiConfig.globalConfig,
      pools: suiConfig.pools,
      type: 'cetus_v1',
      client: suiProvider
    };
    
    console.log('âœ… Cetus DEX contracts initialized on Sui Devnet');
    
  } catch (error) {
    console.error(`âŒ Cetus initialization failed: ${error.message}`);
    console.log('ðŸ”„ Using mock Cetus configuration for development');
    
    // Fallback to mock
    cetusContracts = {
      packageId: null,
      globalConfig: null,
      pools: {},
      type: 'mock',
      client: suiProvider
    };
  };

// Uniswap V3 ABIs and Celo DEX ABIs
const UNISWAP_V3_ABIS = {
  Factory: [
    'function getPool(address tokenA, address tokenB, uint24 fee) external view returns (address pool)',
    'event PoolCreated(address indexed token0, address indexed token1, uint24 indexed fee, int24 tickSpacing, address pool)'
  ],
  Pool: [
    'function slot0() external view returns (uint160 sqrtPriceX96, int24 tick, uint16 observationIndex, uint16 observationCardinality, uint16 observationCardinalityNext, uint8 feeProtocol, bool unlocked)',
    'function liquidity() external view returns (uint128)',
    'function fee() external view returns (uint24)',
    'function token0() external view returns (address)',
    'function token1() external view returns (address)',
    'function tickSpacing() external view returns (int24)'
  ],
  SwapRouter: [
    'function exactInputSingle((address tokenIn, address tokenOut, uint24 fee, address recipient, uint256 deadline, uint256 amountIn, uint256 amountOutMinimum, uint160 sqrtPriceLimitX96)) external payable returns (uint256 amountOut)',
    'function exactOutputSingle((address tokenIn, address tokenOut, uint24 fee, address recipient, uint256 deadline, uint256 amountOut, uint256 amountInMaximum, uint160 sqrtPriceLimitX96)) external payable returns (uint256 amountIn)'
  ],
  Quoter: [
    'function quoteExactInputSingle(address tokenIn, address tokenOut, uint24 fee, uint256 amountIn, uint160 sqrtPriceLimitX96) external returns (uint256 amountOut)',
    'function quoteExactOutputSingle(address tokenIn, address tokenOut, uint24 fee, uint256 amountOut, uint160 sqrtPriceLimitX96) external returns (uint256 amountIn)'
  ]
};

// Initialize providers and SDKs
let ethProvider, celoProvider, suiProvider;
let uniswapContracts = {};

// Cross-chain swap state management
const swapStates = new Map();
const SWAP_TIMEOUT = 3600000; // 1 hour timeout

// Chainlink oracle addresses (TESTNET)
const CHAINLINK_ORACLES = {
  ethereum: {
    USDC_USD: '0xA2F78ab2355fe2f984D808B5CeE7FD0A93D5270E',
    USDT_USD: '0x3f3f5dF88dC9F13eac63DF89EC16ef6e7E25DdE7',
    ETH_USD: '0x694AA1769357215DE4FAC081bf1f309aDC325306',
    decimals: 8
  },
  celo: {
    CUSD_USD: null, // Disabled for development
    USDC_USD: null, // Disabled for development  
    CELO_USD: null, // Disabled for development
    decimals: 8
  },
  sui: {
    USDC_USD: null,
    SUI_USD: null,
    decimals: 8
  }
};

// Global peg monitoring state
let pegStatus = {
  lastCheck: null,
  isActive: false, // Disabled for development
  swapsPaused: false,
  deviations: {},
  alertThreshold: 0.05 // Increased to 5% for testnet
};

async function initializeProviders() {
  try {
    // Ethereum provider
    ethProvider = new ethers.JsonRpcProvider(CHAIN_CONFIG.ethereum.rpc);
    
    // Celo provider
    celoProvider = new ethers.JsonRpcProvider(CHAIN_CONFIG.celo.rpc);
    
    // Sui provider (Devnet)
    suiProvider = new SuiClient({
      url: CHAIN_CONFIG.sui.rpc
    });

    // Initialize Uniswap V3 contracts on Celo
    await initializeUniswapContracts();
    
    // Initialize Cetus contracts on Sui
    await initializeCetusContracts();
    
    console.log('âœ… All providers, SDKs, and DEX contracts initialized successfully');
  } catch (error) {
    console.error('âŒ Provider initialization failed:', error.message);
    process.exit(1);
  }
}

async function initializeUniswapContracts() {
  const celoConfig = CHAIN_CONFIG.celo.uniswap;
  
  try {
    console.log('ðŸ” Initializing Uniswap V3 contracts on Celo Alfajores...');
    
    // Initialize real Uniswap V3 contracts
    const factory = new ethers.Contract(celoConfig.factory, UNISWAP_V3_ABIS.Factory, celoProvider);
    const router = new ethers.Contract(celoConfig.router, UNISWAP_V3_ABIS.SwapRouter, celoProvider);
    const quoter = new ethers.Contract(celoConfig.quoter, UNISWAP_V3_ABIS.Quoter, celoProvider);
    
    // Test the factory contract by calling a simple function
    console.log(`ðŸ§ª Testing Uniswap V3 factory at ${celoConfig.factory}...`);
    
    // Try to get a known pool (this will return 0x0 if pool doesn't exist, but shouldn't throw)
    const testPoolAddress = await factory.getPool(
      CHAIN_CONFIG.celo.tokens.cUSD,
      CHAIN_CONFIG.celo.tokens.USDC,
      3000 // 0.3% fee tier
    );
    
    console.log(`âœ… Uniswap V3 factory is responsive`);
    console.log(`ðŸ“Š Test pool cUSD/USDC (0.3%): ${testPoolAddress === ethers.ZeroAddress ? 'Not created yet' : testPoolAddress}`);
    
    uniswapContracts = {
      factory: factory,
      router: router,
      quoter: quoter,
      type: 'uniswap_v3'
    };
    
    console.log('âœ… Uniswap V3 contracts successfully initialized on Celo Alfajores');
    
  } catch (error) {
    console.error(`âŒ Uniswap V3 initialization failed: ${error.message}`);
    console.log('ðŸ”„ This might be due to network issues or contract verification delays');
    
    // For now, let's still try to create the contracts but mark them as potentially problematic
    try {
      uniswapContracts = {
        factory: new ethers.Contract(celoConfig.factory, UNISWAP_V3_ABIS.Factory, celoProvider),
        router: new ethers.Contract(celoConfig.router, UNISWAP_V3_ABIS.SwapRouter, celoProvider),
        quoter: new ethers.Contract(celoConfig.quoter, UNISWAP_V3_ABIS.Quoter, celoProvider),
        type: 'uniswap_v3_unverified'
      };
      console.log('âš ï¸ Uniswap V3 contracts created but not verified - will use with caution');
    } catch (fallbackError) {
      console.error(`âŒ Complete fallback failed: ${fallbackError.message}`);
      
      // Final fallback to mock
      uniswapContracts = {
        factory: null,
        router: null,
        quoter: null,
        type: 'mock'
      };
      console.log('ðŸ”„ Using mock contracts as final fallback');
    }
  }
}

// Helper function to calculate price from sqrtPriceX96
function calculatePriceFromSqrtPriceX96(sqrtPriceX96, token0, token1, token0Address, token1Address) {
  // Convert BigInt to number for calculation
  const sqrtPrice = Number(sqrtPriceX96) / (2 ** 96);
  const price = sqrtPrice * sqrtPrice;
  
  // Adjust for token decimals (assuming both are 18 decimals for simplicity)
  const token0Decimals = 18;
  const token1Decimals = 18;
  
  const adjustedPrice = price * (10 ** (token0Decimals - token1Decimals));
  
  // Determine which direction the price represents
  const isToken0First = token0.toLowerCase() === token0Address.toLowerCase();
  
  return {
    price0: isToken0First ? adjustedPrice : 1 / adjustedPrice,
    price1: isToken0First ? 1 / adjustedPrice : adjustedPrice,
    raw: price
  };
}

// Helper function for mock prices
function getMockPrice(token0Symbol, token1Symbol) {
  const mockPrices = {
    'cUSD-USDC': 0.999,
    'USDC-cUSD': 1.001,
    'cUSD-CELO': 0.45,
    'CELO-cUSD': 2.22,
    'USDC-CELO': 0.45,
    'CELO-USDC': 2.22
  };
  
  const pair = `${token0Symbol}-${token1Symbol}`;
  return mockPrices[pair] || 1.0;
}

// Helper functions for swap execution
async function calculatePriceImpact(tokenIn, tokenOut, amountIn, fee) {
  try {
    if (uniswapContracts.type === 'uniswap_v3' || uniswapContracts.type === 'uniswap_v3_unverified') {
      // Get current pool price
      const poolAddress = await uniswapContracts.factory.getPool(tokenIn, tokenOut, fee);
      if (poolAddress === ethers.ZeroAddress) return 0;

      const poolContract = new ethers.Contract(poolAddress, UNISWAP_V3_ABIS.Pool, celoProvider);
      const slot0 = await poolContract.slot0();
      
      // Simplified price impact calculation
      const amountInWei = ethers.parseUnits(amountIn, 18);
      const liquidityImpact = Number(amountInWei) / 1e24; // Simplified calculation
      
      return Math.min(liquidityImpact * 100, 5); // Cap at 5%
    }
    
    return 0.05; // Default minimal impact for development
  } catch (error) {
    console.error('Price impact calculation error:', error);
    return 0.05;
  }
}

// Cetus-specific helper functions
async function getCetusPoolPrice(tokenA, tokenB) {
  try {
    if (cetusContracts.type === 'mock') {
      // Return mock price for development
      const pair = `${tokenA}-${tokenB}`;
      const mockPrices = {
        'USDC-USDY': 1.0001,
        'USDY-USDC': 0.9999,
        'USDC-SUI': 0.45,
        'SUI-USDC': 2.22
      };
      return mockPrices[pair] || 1.0;
    }

    // Get pool information from Cetus
    const poolConfig = cetusContracts.pools[`${tokenA}-${tokenB}`];
    if (!poolConfig) {
      throw new Error(`Pool ${tokenA}/${tokenB} not configured`);
    }

    // Query pool state from Sui
    try {
      const poolObject = await suiProvider.getObject({
        id: poolConfig.poolId,
        options: { showContent: true }
      });

      if (poolObject.data && poolObject.data.content) {
        // Extract price from pool state (simplified)
        // In production, you'd parse the actual pool state structure
        return 1.0001; // Mock price for now
      }
    } catch (poolError) {
      console.log('Pool query failed, using fallback price');
    }

    return 1.0; // Fallback price
  } catch (error) {
    console.error('Cetus pool price error:', error);
    return 1.0;
  }
}

async function executeCetusSwap(params) {
  try {
    if (cetusContracts.type === 'mock') {
      // Return mock swap result for development
      return {
        transactionDigest: `0x${randomBytes(32).toString('hex')}`,
        estimatedOutput: (params.amountIn * 0.9995).toString(), // 0.05% fee
        route: 'Cetus DEX on Sui',
        executionTime: '5-15 seconds',
        gasCost: '0.001 SUI'
      };
    }

    // Create Sui transaction block for Cetus swap
    const txb = new TransactionBlock();
    
    // Add Cetus swap call
    txb.moveCall({
      target: `${cetusContracts.packageId}::pool::swap`,
      arguments: [
        txb.pure(params.poolId),
        txb.pure(params.amountIn),
        txb.pure(params.amountOutMin),
        txb.pure(params.sqrtPriceLimit || '0'),
        txb.pure(params.isAToB || true)
      ],
      typeArguments: [params.tokenInType, params.tokenOutType]
    });

    // In production, you'd sign and execute this transaction
    // For now, return mock result
    return {
      transactionDigest: 'mock_tx_digest',
      estimatedOutput: (params.amountIn * 0.9995).toString(),
      route: 'Cetus DEX on Sui Devnet',
      executionTime: '5-15 seconds',
      gasCost: '0.001 SUI'
    };

  } catch (error) {
    throw new Error(`Cetus swap failed: ${error.message}`);
  }
}

async function execute1InchFusionSwapOnSui(params) {
  try {
    // Mock Fusion+ order routing through Cetus
    return {
      orderHash: `0x${randomBytes(32).toString('hex')}`,
      estimatedOutput: (params.amountIn * 0.998).toString(),
      route: '1Inch Fusion+ â†’ Cetus DEX',
      executionTime: '10-30 seconds',
      gasSaved: '10-20%',
      chain: 'sui_devnet'
    };
  } catch (error) {
    throw new Error(`1Inch Fusion+ swap on Sui failed: ${error.message}`);
  }
}

async function execute1InchFusionSwapOnCelo(params) {
  try {
    // Mock Fusion+ order for development
    return {
      orderHash: `0x${randomBytes(32).toString('hex')}`,
      estimatedOutput: (params.amountIn * 0.998).toString(),
      route: '1Inch Fusion+ â†’ Uniswap V3',
      executionTime: '30-120 seconds',
      gasSaved: '15-25%'
    };
  } catch (error) {
    throw new Error(`1Inch Fusion+ swap failed: ${error.message}`);
  }
}

async function executeDirectUniswapSwap(params) {
  try {
    // Mock direct swap for development
    return {
      txHash: `0x${randomBytes(32).toString('hex')}`,
      amountOut: (params.amountIn * 0.997).toString(),
      route: 'Direct Uniswap V3',
      gasUsed: '150000',
      effectiveGasPrice: '500000000'
    };
  } catch (error) {
    throw new Error(`Direct Uniswap swap failed: ${error.message}`);
  }
}

async function estimateSwapGas(params) {
  return {
    gasLimit: '150000',
    gasPrice: '20',
    estimatedCost: '0.003 ETH'
  };
}

// Health check endpoint
app.get('/health', (req, res) => {
  res.json({ 
    status: 'healthy', 
    timestamp: new Date().toISOString(),
    chains: Object.keys(CHAIN_CONFIG)
  });
});

// Test endpoint
app.get('/api/test', (req, res) => {
  res.json({ message: 'Test endpoint works!', timestamp: new Date().toISOString() });
});

// 1. Fetch stablecoin prices from 1Inch API
app.get('/api/prices/1inch', async (req, res) => {
  try {
    const { tokens = 'USDC,USDT,DAI' } = req.query;
    
    const response = await axios.get('https://api.1inch.dev/price/v1.1/1', {
      params: {
        tokens: tokens,
        currency: 'USD'
      },
      headers: {
        'Authorization': `Bearer ${process.env.ONEINCH_API_KEY}`
      }
    });

    const prices = response.data;
    
    res.json({
      success: true,
      data: prices,
      timestamp: new Date().toISOString(),
      source: '1inch'
    });
  } catch (error) {
    console.error('1Inch price fetch error:', error.message);
    res.status(500).json({
      success: false,
      error: 'Failed to fetch prices from 1Inch',
      details: error.message
    });
  }
});

// 2. Detect arbitrage opportunities between Celo and Sui
app.get('/api/arbitrage/celo-sui', async (req, res) => {
  try {
    const { minProfit = 0.5 } = req.query;
    
    // Mock arbitrage data for development
    const opportunities = [
      {
        pair: 'cUSD/USDC',
        direction: 'CELO->SUI',
        celoPrice: 0.999,
        suiPrice: 1.002,
        priceDiff: 0.003,
        profitPercent: '0.30',
        estimatedGasCost: { ethereum: '0.01', celo: '0.001', sui: '0.0001' },
        recommendedAmount: 1000
      }
    ];

    res.json({
      success: true,
      data: {
        opportunities,
        totalOpportunities: opportunities.length,
        timestamp: new Date().toISOString(),
        prices: { celoPrice: 0.999, suiPrice: 1.002, ethPrice: 1.0 }
      }
    });
  } catch (error) {
    console.error('Arbitrage detection error:', error.message);
    res.status(500).json({
      success: false,
      error: 'Failed to detect arbitrage opportunities',
      details: error.message
    });
  }
});

// 3. Real Uniswap V3 price fetching for Celo pairs
app.get('/api/uniswap/price/:pair', async (req, res) => {
  try {
    const { pair } = req.params;
    const { fee = 3000 } = req.query;
    
    // Parse pair (e.g., "cUSD-USDC")
    const [token0Symbol, token1Symbol] = pair.split('-');
    const token0Address = CHAIN_CONFIG.celo.tokens[token0Symbol];
    const token1Address = CHAIN_CONFIG.celo.tokens[token1Symbol];
    
    if (!token0Address || !token1Address) {
      return res.status(400).json({
        success: false,
        error: 'Invalid token pair',
        availableTokens: Object.keys(CHAIN_CONFIG.celo.tokens)
      });
    }

    console.log(`ðŸ” Processing price request for ${pair} with DEX type: ${uniswapContracts.type}`);

    // Handle real Uniswap V3 integration
    if (uniswapContracts.type === 'uniswap_v3' || uniswapContracts.type === 'uniswap_v3_unverified') {
      try {
        console.log('ðŸ¦„ Fetching real Uniswap V3 data from Celo...');
        
        // Get pool address from factory
        const poolAddress = await uniswapContracts.factory.getPool(
          token0Address, 
          token1Address, 
          fee
        );

        if (poolAddress === ethers.ZeroAddress) {
          return res.status(404).json({
            success: false,
            error: 'Pool not found for this pair and fee tier',
            suggestion: 'Try different fee tiers: 500 (0.05%), 3000 (0.3%), 10000 (1%)',
            availableFees: [500, 3000, 10000],
            note: 'Pool may not be created yet. You can create it via Uniswap interface.'
          });
        }

        // Get pool contract and fetch data
        const poolContract = new ethers.Contract(poolAddress, UNISWAP_V3_ABIS.Pool, celoProvider);
        
        const [slot0, liquidity, token0, token1] = await Promise.all([
          poolContract.slot0(),
          poolContract.liquidity(),
          poolContract.token0(),
          poolContract.token1()
        ]);

        // Calculate price from sqrtPriceX96
        const sqrtPriceX96 = slot0.sqrtPriceX96;
        const price = calculatePriceFromSqrtPriceX96(sqrtPriceX96, token0, token1, token0Address, token1Address);
        
        return res.json({
          success: true,
          data: {
            pair,
            poolAddress,
            fee: fee / 10000,
            price: {
              token0ToToken1: price.price0,
              token1ToToken0: price.price1,
              formatted: `1 ${token0Symbol} = ${price.price0.toFixed(6)} ${token1Symbol}`
            },
            poolStats: {
              sqrtPriceX96: sqrtPriceX96.toString(),
              tick: slot0.tick,
              liquidity: liquidity.toString(),
              unlocked: slot0.unlocked,
              feeProtocol: slot0.feeProtocol
            },
            tokens: {
              token0: { address: token0, symbol: token0Symbol },
              token1: { address: token1, symbol: token1Symbol }
            },
            timestamp: new Date().toISOString(),
            source: 'uniswap_v3_celo_alfajores',
            network: 'Celo Alfajores Testnet'
          }
        });
        
      } catch (contractError) {
        console.error('ðŸ”´ Uniswap V3 contract call failed:', contractError.message);
        
        return res.status(500).json({
          success: false,
          error: 'Uniswap V3 contract call failed',
          details: contractError.message,
          contractAddresses: {
            factory: CHAIN_CONFIG.celo.uniswap.factory,
            router: CHAIN_CONFIG.celo.uniswap.router,
            quoter: CHAIN_CONFIG.celo.uniswap.quoter
          },
          suggestion: 'Check if contracts are verified on Alfajores explorer, or pool may not exist yet',
          fallback: 'You can try creating the pool first on Uniswap interface'
        });
      }
    }

    // Fallback to mock if contracts not available
    console.log('âš ï¸ Using mock data - Uniswap V3 not available');
    const mockPrice = getMockPrice(token0Symbol, token1Symbol);
    
    res.json({
      success: true,
      data: {
        pair,
        price: {
          token0ToToken1: mockPrice,
          token1ToToken0: 1 / mockPrice,
          formatted: `1 ${token0Symbol} = ${mockPrice.toFixed(6)} ${token1Symbol}`
        },
        poolAddress: 'mock_pool_address',
        source: 'mock_fallback',
        note: 'Mock data - real Uniswap V3 integration failed',
        timestamp: new Date().toISOString()
      }
    });

  } catch (error) {
    console.error('DEX price fetch error:', error.message);
    
    const [token0Symbol, token1Symbol] = req.params.pair.split('-');
    const mockPrice = getMockPrice(token0Symbol, token1Symbol);
    
    res.json({
      success: true,
      data: {
        pair: req.params.pair,
        price: {
          token0ToToken1: mockPrice,
          token1ToToken0: 1 / mockPrice,
          formatted: `1 ${token0Symbol} = ${mockPrice.toFixed(6)} ${token1Symbol}`
        },
        source: 'error_fallback_mock',
        note: 'Using mock data due to error',
        originalError: error.message,
        timestamp: new Date().toISOString()
      }
    });
  }
});

// 4. Get multiple pool prices and find best rates
app.get('/api/uniswap/pools/:pair', async (req, res) => {
  try {
    const { pair } = req.params;
    const [token0Symbol, token1Symbol] = pair.split('-');
    const token0Address = CHAIN_CONFIG.celo.tokens[token0Symbol];
    const token1Address = CHAIN_CONFIG.celo.tokens[token1Symbol];
    
    if (!token0Address || !token1Address) {
      return res.status(400).json({
        success: false,
        error: 'Invalid token pair',
        availableTokens: Object.keys(CHAIN_CONFIG.celo.tokens)
      });
    }

    // Handle real Uniswap V3
    if (uniswapContracts.type === 'uniswap_v3' || uniswapContracts.type === 'uniswap_v3_unverified') {
      const feeTiers = [500, 3000, 10000]; // 0.05%, 0.3%, 1%
      const poolData = [];

      for (const fee of feeTiers) {
        try {
          const poolAddress = await uniswapContracts.factory.getPool(token0Address, token1Address, fee);
          
          if (poolAddress !== ethers.ZeroAddress) {
            const poolContract = new ethers.Contract(poolAddress, UNISWAP_V3_ABIS.Pool, celoProvider);
            const [slot0, liquidity] = await Promise.all([
              poolContract.slot0(),
              poolContract.liquidity()
            ]);

            const price = calculatePriceFromSqrtPriceX96(
              slot0.sqrtPriceX96, 
              await poolContract.token0(), 
              await poolContract.token1(),
              token0Address, 
              token1Address
            );

            poolData.push({
              fee: fee / 10000,
              poolAddress,
              price: price.price0,
              liquidity: liquidity.toString(),
              tick: slot0.tick,
              sqrtPriceX96: slot0.sqrtPriceX96.toString(),
              active: true,
              dexType: 'uniswap_v3'
            });
          }
        } catch (error) {
          console.error(`Error fetching pool for fee ${fee}:`, error.message);
        }
      }

      // Sort by liquidity
      poolData.sort((a, b) => BigInt(b.liquidity) - BigInt(a.liquidity));

      return res.json({
        success: true,
        data: {
          pair,
          pools: poolData,
          bestLiquidity: poolData[0] || null,
          totalPools: poolData.length,
          recommendation: poolData.length > 0 ? 
            `Use ${poolData[0].fee}% fee pool for best liquidity` : 
            'No active pools found - create pool via Uniswap interface',
          source: 'uniswap_v3_celo_alfajores'
        }
      });
    }

    // Fallback to mock
    const mockPrice = getMockPrice(token0Symbol, token1Symbol);
    return res.json({
      success: true,
      data: {
        pair,
        pools: [{
          fee: 0.3,
          poolAddress: 'mock_address',
          price: mockPrice,
          liquidity: '1000000000000000000000',
          active: true,
          dexType: 'mock'
        }],
        bestLiquidity: { fee: 0.3, price: mockPrice, dexType: 'mock' },
        totalPools: 1,
        recommendation: 'Mock data for development testing'
      }
    });

  } catch (error) {
    console.error('Pools fetch error:', error.message);
    res.status(500).json({
      success: false,
      error: 'Failed to fetch pool data',
      details: error.message
    });
  }
});

// 5. Execute Uniswap V3 swap on Celo via 1Inch Fusion+
app.post('/api/uniswap/swap', async (req, res) => {
  try {
    const {
      tokenIn,
      tokenOut,
      amountIn,
      amountOutMinimum,
      fee = 3000,
      walletAddress,
      slippageTolerance = 1,
      useExactOutput = false,
      routeVia1Inch = true
    } = req.body;

    if (!tokenIn || !tokenOut || !amountIn || !walletAddress) {
      return res.status(400).json({
        success: false,
        error: 'Missing required parameters: tokenIn, tokenOut, amountIn, walletAddress'
      });
    }

    const tokenInAddress = CHAIN_CONFIG.celo.tokens[tokenIn];
    const tokenOutAddress = CHAIN_CONFIG.celo.tokens[tokenOut];

    if (!tokenInAddress || !tokenOutAddress) {
      return res.status(400).json({
        success: false,
        error: 'Invalid token symbols',
        availableTokens: Object.keys(CHAIN_CONFIG.celo.tokens)
      });
    }

    let swapResult;

    if (routeVia1Inch) {
      // Route through 1Inch Fusion+ for better rates and MEV protection
      swapResult = await execute1InchFusionSwapOnCelo({
        tokenIn: tokenInAddress,
        tokenOut: tokenOutAddress,
        amountIn,
        walletAddress,
        slippageTolerance
      });
    } else {
      // Direct Uniswap V3 swap
      swapResult = await executeDirectUniswapSwap({
        tokenIn: tokenInAddress,
        tokenOut: tokenOutAddress,
        amountIn,
        amountOutMinimum,
        fee,
        walletAddress,
        useExactOutput
      });
    }

    res.json({
      success: true,
      data: {
        ...swapResult,
        routing: routeVia1Inch ? '1Inch Fusion+ â†’ Uniswap V3' : 'Direct Uniswap V3',
        chain: 'celo_alfajores',
        estimatedGas: await estimateSwapGas({ tokenIn, tokenOut, amountIn })
      }
    });

  } catch (error) {
    console.error('Uniswap swap error:', error.message);
    res.status(500).json({
      success: false,
      error: 'Failed to execute Uniswap swap',
      details: error.message
    });
  }
});

// 6. Get swap quote from available DEX (Celo Uniswap)
app.get('/api/cetus/price/:pair', async (req, res) => {
  try {
    const { pair } = req.params;
    
    // Parse pair (e.g., "USDC-USDY")
    const [token0Symbol, token1Symbol] = pair.split('-');
    const token0Address = CHAIN_CONFIG.sui.tokens[token0Symbol];
    const token1Address = CHAIN_CONFIG.sui.tokens[token1Symbol];
    
    if (!token0Address || !token1Address) {
      return res.status(400).json({
        success: false,
        error: 'Invalid token pair',
        availableTokens: Object.keys(CHAIN_CONFIG.sui.tokens)
      });
    }

    console.log(`ðŸŒŠ Processing Cetus price request for ${pair} on Sui Devnet`);

    // Get price from Cetus
    const price = await getCetusPoolPrice(token0Symbol, token1Symbol);
    
    // Get pool configuration
    const poolConfig = cetusContracts.pools[pair] || null;

    res.json({
      success: true,
      data: {
        pair,
        price: {
          token0ToToken1: price,
          token1ToToken0: 1 / price,
          formatted: `1 ${token0Symbol} = ${price.toFixed(6)} ${token1Symbol}`
        },
        poolConfig: poolConfig ? {
          poolId: poolConfig.poolId,
          tickSpacing: poolConfig.tickSpacing,
          feeRate: poolConfig.feeRate / 10000 // Convert to percentage
        } : null,
        tokens: {
          token0: { address: token0Address, symbol: token0Symbol },
          token1: { address: token1Address, symbol: token1Symbol }
        },
        timestamp: new Date().toISOString(),
        source: 'cetus_sui_devnet',
        network: 'Sui Devnet',
        dexType: cetusContracts.type
      }
    });

  } catch (error) {
    console.error('Cetus price fetch error:', error.message);
    
    // Return mock data on error
    const [token0Symbol, token1Symbol] = req.params.pair.split('-');
    const mockPrice = 1.0001;
    
    res.json({
      success: true,
      data: {
        pair: req.params.pair,
        price: {
          token0ToToken1: mockPrice,
          token1ToToken0: 1 / mockPrice,
          formatted: `1 ${token0Symbol} = ${mockPrice.toFixed(6)} ${token1Symbol}`
        },
        source: 'mock_fallback_cetus',
        note: 'Using mock data due to error',
        originalError: error.message,
        timestamp: new Date().toISOString()
      }
    });
  }
});

// 12. Execute Cetus swap on Sui Devnet via 1Inch Fusion+
app.post('/api/cetus/swap', async (req, res) => {
  try {
    const {
      tokenIn,
      tokenOut,
      amountIn,
      amountOutMinimum,
      walletAddress,
      slippageTolerance = 1,
      routeVia1Inch = true
    } = req.body;

    // Validate inputs
    if (!tokenIn || !tokenOut || !amountIn || !walletAddress) {
      return res.status(400).json({
        success: false,
        error: 'Missing required parameters: tokenIn, tokenOut, amountIn, walletAddress'
      });
    }

    const tokenInAddress = CHAIN_CONFIG.sui.tokens[tokenIn];
    const tokenOutAddress = CHAIN_CONFIG.sui.tokens[tokenOut];

    if (!tokenInAddress || !tokenOutAddress) {
      return res.status(400).json({
        success: false,
        error: 'Invalid token symbols',
        availableTokens: Object.keys(CHAIN_CONFIG.sui.tokens)
      });
    }

    let swapResult;

    if (routeVia1Inch) {
      // Route through 1Inch Fusion+ for better rates and MEV protection
      swapResult = await execute1InchFusionSwapOnSui({
        tokenIn: tokenInAddress,
        tokenOut: tokenOutAddress,
        amountIn,
        walletAddress,
        slippageTolerance
      });
    } else {
      // Direct Cetus swap
      const poolConfig = cetusContracts.pools[`${tokenIn}-${tokenOut}`];
      swapResult = await executeCetusSwap({
        poolId: poolConfig?.poolId || 'mock_pool',
        tokenInType: tokenInAddress,
        tokenOutType: tokenOutAddress,
        amountIn,
        amountOutMin: amountOutMinimum || 0,
        walletAddress
      });
    }

    res.json({
      success: true,
      data: {
        ...swapResult,
        routing: routeVia1Inch ? '1Inch Fusion+ â†’ Cetus DEX' : 'Direct Cetus DEX',
        chain: 'sui_devnet',
        estimatedGas: {
          gasCost: '0.001 SUI',
          gasPrice: '1000 MIST',
          estimatedCost: '~$0.001'
        }
      }
    });

  } catch (error) {
    console.error('Cetus swap error:', error.message);
    res.status(500).json({
      success: false,
      error: 'Failed to execute Cetus swap',
      details: error.message
    });
  }
});

// 13. Get Cetus swap quote
app.get('/api/cetus/quote', async (req, res) => {
  try {
    const {
      tokenIn,
      tokenOut,
      amountIn
    } = req.query;

    if (!tokenIn || !tokenOut || !amountIn) {
      return res.status(400).json({
        success: false,
        error: 'Missing required parameters: tokenIn, tokenOut, amountIn'
      });
    }

    const tokenInAddress = CHAIN_CONFIG.sui.tokens[tokenIn];
    const tokenOutAddress = CHAIN_CONFIG.sui.tokens[tokenOut];

    if (!tokenInAddress || !tokenOutAddress) {
      return res.status(400).json({
        success: false,
        error: 'Invalid token symbols',
        availableTokens: Object.keys(CHAIN_CONFIG.sui.tokens)
      });
    }

    // Get price from Cetus
    const price = await getCetusPoolPrice(tokenIn, tokenOut);
    const amountOut = parseFloat(amountIn) * price;
    
    // Calculate fees (simplified)
    const poolConfig = cetusContracts.pools[`${tokenIn}-${tokenOut}`];
    const feeRate = poolConfig ? poolConfig.feeRate / 10000 : 0.05; // Default 0.05%
    const finalAmountOut = amountOut * (1 - feeRate);

    res.json({
      success: true,
      data: {
        tokenIn,
        tokenOut,
        amountIn: parseFloat(amountIn),
        amountOut: finalAmountOut,
        price: price,
        feeRate: feeRate,
        priceImpact: '0.01', // Mock price impact
        route: `${tokenIn} â†’ ${tokenOut} (Cetus DEX)`,
        poolId: poolConfig?.poolId || 'mock_pool',
        timestamp: new Date().toISOString(),
        source: 'cetus_sui_devnet'
      }
    });

  } catch (error) {
    console.error('Cetus quote error:', error.message);
    res.status(500).json({
      success: false,
      error: 'Failed to get Cetus quote',
      details: error.message
    });
  }
});

// 14. Cross-chain arbitrage detection (Celo â†” Sui)
app.get('/api/arbitrage/celo-sui-enhanced', async (req, res) => {
  try {
    const { minProfit = 0.5 } = req.query;
    
    // Get prices from both chains
    const celoPrice = getMockPrice('cUSD', 'USDC'); // From Celo Uniswap
    const suiPrice = await getCetusPoolPrice('USDC', 'USDY'); // From Sui Cetus
    
    const opportunities = [];
    
    // Calculate cross-chain arbitrage
    const priceDiff = Math.abs(celoPrice - suiPrice);
    const profitPercent = (priceDiff / Math.min(celoPrice, suiPrice)) * 100;
    
    if (profitPercent >= parseFloat(minProfit)) {
      const direction = celoPrice > suiPrice ? 'CELO->SUI' : 'SUI->CELO';
      
      opportunities.push({
        pair: 'USDC Cross-Chain',
        direction,
        celoPrice: celoPrice,
        suiPrice: suiPrice,
        priceDiff: priceDiff,
        profitPercent: profitPercent.toFixed(2),
        estimatedGasCost: {
          celo: '0.001 CELO',
          sui: '0.001 SUI',
          ethereum: '0.01 ETH' // For bridging
        },
        recommendedAmount: Math.min(10000, 1000 / priceDiff),
        route: direction === 'CELO->SUI' ? 'Uniswap V3 â†’ Bridge â†’ Cetus' : 'Cetus â†’ Bridge â†’ Uniswap V3'
      });
    }

    res.json({
      success: true,
      data: {
        opportunities,
        totalOpportunities: opportunities.length,
        timestamp: new Date().toISOString(),
        prices: { 
          celoPrice, 
          suiPrice, 
          bridgeAvailable: true 
        },
        chains: ['celo_alfajores', 'sui_devnet']
      }
    });
  } catch (error) {
    console.error('Enhanced arbitrage detection error:', error.message);
    res.status(500).json({
      success: false,
      error: 'Failed to detect cross-chain arbitrage opportunities',
      details: error.message
    });
  }
});
app.get('/api/uniswap/quote', async (req, res) => {
  try {
    const {
      tokenIn,
      tokenOut,
      amountIn,
      fee = 3000
    } = req.query;

    if (!tokenIn || !tokenOut || !amountIn) {
      return res.status(400).json({
        success: false,
        error: 'Missing required parameters: tokenIn, tokenOut, amountIn'
      });
    }

    const tokenInAddress = CHAIN_CONFIG.celo.tokens[tokenIn];
    const tokenOutAddress = CHAIN_CONFIG.celo.tokens[tokenOut];

    if (!tokenInAddress || !tokenOutAddress) {
      return res.status(400).json({
        success: false,
        error: 'Invalid token symbols',
        availableTokens: Object.keys(CHAIN_CONFIG.celo.tokens)
      });
    }

    if (uniswapContracts.type === 'uniswap_v3' || uniswapContracts.type === 'uniswap_v3_unverified') {
      try {
        // Use Uniswap V3 quoter
        const amountOut = await uniswapContracts.quoter.quoteExactInputSingle.staticCall(
          tokenInAddress,
          tokenOutAddress,
          fee,
          ethers.parseUnits(amountIn, 18),
          0 // sqrtPriceLimitX96 = 0 (no limit)
        );

        const rate = Number(amountOut) / Number(ethers.parseUnits(amountIn, 18));
        const priceImpact = await calculatePriceImpact(tokenInAddress, tokenOutAddress, amountIn, fee);

        return res.json({
          success: true,
          data: {
            tokenIn,
            tokenOut,
            amountIn,
            amountOut: ethers.formatUnits(amountOut, 18),
            rate: rate.toFixed(6),
            fee: fee / 10000,
            priceImpact: priceImpact.toFixed(4),
            route: `${tokenIn} â†’ ${tokenOut} (Uniswap V3)`,
            timestamp: new Date().toISOString(),
            source: 'uniswap_v3_celo_alfajores'
          }
        });
      } catch (error) {
        console.error('Uniswap V3 quote error:', error);
        // Fallback to mock quote
      }
    }

    // Fallback mock quote
    const mockPrice = getMockPrice(tokenIn, tokenOut);
    const amountOut = parseFloat(amountIn) * mockPrice;
    
    res.json({
      success: true,
      data: {
        tokenIn,
        tokenOut,
        amountIn: parseFloat(amountIn),
        amountOut: amountOut,
        rate: mockPrice.toFixed(6),
        fee: 0.3,
        priceImpact: '0.05',
        route: `${tokenIn} â†’ ${tokenOut} (Mock)`,
        timestamp: new Date().toISOString(),
        source: 'mock_fallback'
      }
    });

  } catch (error) {
    console.error('Quote error:', error.message);
    res.status(500).json({
      success: false,
      error: 'Failed to get swap quote',
      details: error.message
    });
  }
});

// 7. Bidirectional stablecoin swap with atomic guarantees
app.post('/api/swap/bidirectional', async (req, res) => {
  try {
    const {
      fromChain,
      toChain,
      fromToken,
      toToken,
      amount,
      walletAddress,
      minRate,
      maxSlippage = 1,
      enableAtomicSwap = true,
      timeoutMinutes = 60
    } = req.body;

    // Validate chains and direction
    const supportedPairs = [
      { from: 'celo', to: 'sui', via: 'ethereum' },
      { from: 'sui', to: 'celo', via: 'ethereum' },
      { from: 'celo', to: 'ethereum', direct: true },
      { from: 'ethereum', to: 'celo', direct: true }
    ];

    const swapPair = supportedPairs.find(p => p.from === fromChain && p.to === toChain);
    if (!swapPair) {
      return res.status(400).json({
        success: false,
        error: 'Unsupported swap direction',
        supportedPairs
      });
    }

    // Generate unique swap ID and hashlock
    const swapId = `swap_${Date.now()}_${randomBytes(8).toString('hex')}`;
    const secret = randomBytes(32);
    const hashlock = createHash('sha256').update(secret).digest('hex');
    const timelock = Math.floor(Date.now() / 1000) + (timeoutMinutes * 60);

    // Initialize swap state
    const swapState = {
      id: swapId,
      fromChain,
      toChain,
      fromToken,
      toToken,
      amount,
      walletAddress,
      minRate,
      maxSlippage,
      enableAtomicSwap,
      hashlock,
      secret: secret.toString('hex'),
      timelock,
      status: 'INITIATED',
      steps: [],
      createdAt: new Date().toISOString()
    };

    swapStates.set(swapId, swapState);

    // Create execution plan
    const executionPlan = {
      type: swapPair.direct ? 'DIRECT_SWAP' : 'CROSS_CHAIN_SWAP',
      steps: [
        {
          type: 'RATE_CHECK',
          description: 'Check if current rate meets minimum threshold',
          chain: fromChain,
          status: 'PENDING'
        },
        {
          type: 'FUSION_SWAP',
          description: 'Execute swap via 1Inch Fusion+',
          chain: fromChain,
          status: 'PENDING'
        }
      ],
      estimatedGas: '0.01 ETH',
      estimatedTime: swapPair.direct ? '2-5 minutes' : '10-30 minutes'
    };

    swapState.executionPlan = executionPlan;
    swapState.status = 'PLAN_CREATED';

    res.json({
      success: true,
      data: {
        swapId,
        executionPlan,
        atomicGuarantees: enableAtomicSwap ? {
          hashlock,
          timelock: new Date(timelock * 1000).toISOString(),
          expiresIn: `${timeoutMinutes} minutes`
        } : null,
        estimatedTime: swapPair.direct ? '2-5 minutes' : '10-30 minutes',
        nextStep: 'Execute swap using /api/swap/execute endpoint'
      }
    });

  } catch (error) {
    console.error('Bidirectional swap error:', error.message);
    res.status(500).json({
      success: false,
      error: 'Failed to create bidirectional swap',
      details: error.message
    });
  }
});

// 8. Execute atomic swap with threshold checks
app.post('/api/swap/execute', async (req, res) => {
  try {
    const { swapId, step = 0 } = req.body;

    const swapState = swapStates.get(swapId);
    if (!swapState) {
      return res.status(404).json({
        success: false,
        error: 'Swap not found'
      });
    }

    // Check if swap expired
    if (Date.now() / 1000 > swapState.timelock) {
      swapState.status = 'EXPIRED';
      return res.status(408).json({
        success: false,
        error: 'Swap expired',
        refundInstructions: 'Use /api/swap/refund endpoint'
      });
    }

    // Mock execution result
    const executionResult = {
      status: 'COMPLETED',
      txHash: `0x${randomBytes(32).toString('hex')}`,
      message: 'Step executed successfully'
    };

    // Update swap state
    swapState.steps[step] = {
      ...swapState.executionPlan.steps[step],
      ...executionResult,
      executedAt: new Date().toISOString()
    };

    const allStepsComplete = step >= swapState.executionPlan.steps.length - 1;
    if (allStepsComplete) {
      swapState.status = 'COMPLETED';
      swapState.completedAt = new Date().toISOString();
    }

    res.json({
      success: true,
      data: {
        swapId,
        currentStep: step,
        stepResult: executionResult,
        swapStatus: swapState.status,
        nextStep: allStepsComplete ? null : step + 1,
        isComplete: allStepsComplete
      }
    });

  } catch (error) {
    console.error('Swap execution error:', error.message);
    res.status(500).json({
      success: false,
      error: 'Failed to execute swap step',
      details: error.message
    });
  }
});

// 9. Get swap status and progress
app.get('/api/swap/status/:swapId', async (req, res) => {
  try {
    const { swapId } = req.params;
    const swapState = swapStates.get(swapId);

    if (!swapState) {
      return res.status(404).json({
        success: false,
        error: 'Swap not found'
      });
    }

    // Calculate progress
    const completedSteps = swapState.steps.filter(s => s.status === 'COMPLETED').length;
    const totalSteps = swapState.executionPlan.steps.length;
    const progress = (completedSteps / totalSteps) * 100;

    // Check for expired swaps
    const isExpired = Date.now() / 1000 > swapState.timelock;
    if (isExpired && swapState.status !== 'EXPIRED') {
      swapState.status = 'EXPIRED';
    }

    res.json({
      success: true,
      data: {
        swapId,
        status: swapState.status,
        progress: Math.round(progress),
        completedSteps,
        totalSteps,
        currentStep: swapState.steps.findIndex(s => !s.status || s.status === 'PENDING'),
        timeRemaining: Math.max(0, swapState.timelock - Math.floor(Date.now() / 1000)),
        createdAt: swapState.createdAt,
        updatedAt: swapState.updatedAt || swapState.createdAt,
        executionPlan: swapState.executionPlan,
        atomicGuarantees: swapState.enableAtomicSwap ? {
          hashlock: swapState.hashlock,
          timelock: swapState.timelock
        } : null
      }
    });

  } catch (error) {
    console.error('Swap status error:', error.message);
    res.status(500).json({
      success: false,
      error: 'Failed to get swap status',
      details: error.message
    });
  }
});

// 10. Refund expired or failed atomic swaps
app.post('/api/swap/refund', async (req, res) => {
  try {
    const { swapId } = req.body;
    const swapState = swapStates.get(swapId);

    if (!swapState) {
      return res.status(404).json({
        success: false,
        error: 'Swap not found'
      });
    }

    // Check if refund is allowed
    const canRefund = swapState.status === 'EXPIRED' || 
                     swapState.status === 'FAILED' ||
                     Date.now() / 1000 > swapState.timelock;

    if (!canRefund) {
      return res.status(400).json({
        success: false,
        error: 'Refund not available yet',
        timeRemaining: Math.max(0, swapState.timelock - Math.floor(Date.now() / 1000))
      });
    }

    // Execute refund logic
    const refundResult = {
      refundTxHash: `0x${randomBytes(32).toString('hex')}`,
      amount: swapState.amount,
      token: swapState.fromToken,
      chain: swapState.fromChain,
      message: 'Refund processed successfully'
    };
    
    swapState.status = 'REFUNDED';
    swapState.refundedAt = new Date().toISOString();

    res.json({
      success: true,
      data: {
        swapId,
        refundResult,
        status: 'REFUNDED'
      }
    });

  } catch (error) {
    console.error('Refund error:', error.message);
    res.status(500).json({
      success: false,
      error: 'Failed to process refund',
      details: error.message
    });
  }
});

// Oracle peg monitoring endpoint
app.get('/api/oracle/peg-status', async (req, res) => {
  try {
    res.json({
      success: true,
      data: {
        chainStatus: {
          ethereum: { USDC_USD: { status: 'STABLE', price: 1.0001 } },
          celo: { CUSD_USD: { status: 'STABLE', price: 0.9999 } }
        },
        globalStatus: {
          swapsPaused: pegStatus.swapsPaused,
          lastCheck: new Date().toISOString(),
          criticalDepegs: 0,
          alertThreshold: `${pegStatus.alertThreshold * 100}%`
        },
        criticalAlerts: []
      }
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      error: 'Failed to check peg status',
      details: error.message
    });
  }
});

// Enhanced Chainlink oracle with multi-chain peg monitoring
app.get('/api/oracle/chainlink/:pair', async (req, res) => {
  try {
    const { pair } = req.params;
    const { chain = 'ethereum' } = req.query;
    
    // Mock oracle response for development
    res.json({
      success: true,
      data: {
        chain,
        pair,
        price: 1.0001,
        updatedAt: new Date(),
        roundId: '12345',
        pegAnalysis: {
          isPegged: true,
          deviation: 0.0001,
          deviationPercent: '0.01',
          target: 1.0,
          status: 'STABLE',
          severity: 'LOW'
        },
        dataAge: 30000
      },
      source: 'chainlink'
    });
  } catch (error) {
    console.error('Chainlink oracle error:', error.message);
    res.status(500).json({
      success: false,
      error: 'Failed to fetch oracle data',
      details: error.message
    });
  }
});

// Oracle controls endpoint
app.post('/api/oracle/peg-controls', async (req, res) => {
  try {
    const { action, threshold } = req.body;
    
    switch (action) {
      case 'pause_swaps':
        pegStatus.swapsPaused = true;
        break;
      case 'resume_swaps':
        pegStatus.swapsPaused = false;
        break;
      case 'set_threshold':
        if (threshold && threshold > 0 && threshold <= 0.1) {
          pegStatus.alertThreshold = threshold;
        }
        break;
      case 'force_check':
        // Trigger immediate peg check
        break;
      default:
        throw new Error('Invalid action');
    }

    res.json({
      success: true,
      data: {
        action,
        newStatus: {
          swapsPaused: pegStatus.swapsPaused,
          alertThreshold: pegStatus.alertThreshold,
          lastAction: new Date().toISOString()
        }
      }
    });
  } catch (error) {
    res.status(400).json({
      success: false,
      error: error.message
    });
  }
});

// Error handling middleware
app.use((error, req, res, next) => {
  console.error('Unhandled error:', error);
  res.status(500).json({
    success: false,
    error: 'Internal server error',
    timestamp: new Date().toISOString()
  });
});

// Start server with peg monitoring, swap cleanup, and Uniswap integration
async function startServer() {
  await initializeProviders();
  
  // Check if in development mode
  const isDevelopment = process.env.NODE_ENV !== 'production';
  
  if (isDevelopment) {
    console.log('ðŸ› ï¸ Development mode: Peg monitoring disabled');
    pegStatus.isActive = false;
    pegStatus.swapsPaused = false;
  }
  
  // Cleanup expired swaps (every 5 minutes)
  setInterval(() => {
    const now = Date.now() / 1000;
    let cleanedCount = 0;
    
    for (const [swapId, swapState] of swapStates.entries()) {
      if (now > swapState.timelock + 3600) { // 1 hour after expiry
        swapStates.delete(swapId);
        cleanedCount++;
      }
    }
    
    if (cleanedCount > 0) {
      console.log(`ðŸ§¹ Cleaned up ${cleanedCount} expired swaps`);
    }
  }, 300000);
  
  app.listen(PORT, 'localhost', () => {
    console.log(`ðŸš€ DeFi Bridge API server running on port ${PORT}`);
    console.log(`ðŸ“Š Health check: http://localhost:${PORT}/health`);
    console.log(`ðŸ”— Supported chains: ${Object.keys(CHAIN_CONFIG).join(', ')}`);
    console.log(`ðŸ›¡ï¸ Peg monitoring: ${pegStatus.isActive ? 'Active' : 'Disabled'} (threshold: ${pegStatus.alertThreshold * 100}%)`);
    console.log(`âš›ï¸ Atomic swaps: Enabled with hashlock/timelock`);
    console.log(`ðŸ¦„ DEX Integration: Uniswap V3 (${uniswapContracts.type}), Cetus (${cetusContracts.type})`);
    console.log(`ðŸ“ˆ Swap endpoints:`);
    console.log(`   - POST /api/swap/bidirectional - Create atomic cross-chain swap`);
    console.log(`   - POST /api/swap/execute - Execute swap steps`);
    console.log(`   - GET /api/swap/status/:swapId - Check swap progress`);
    console.log(`   - POST /api/swap/refund - Refund expired swaps`);
    console.log(`ðŸ¦„ Uniswap V3 endpoints (Celo):`);
    console.log(`   - GET /api/uniswap/price/:pair - Get pool price (e.g., cUSD-USDC)`);
    console.log(`   - GET /api/uniswap/pools/:pair - Compare all fee tiers`);
    console.log(`   - POST /api/uniswap/swap - Execute swap via Fusion+ or direct`);
    console.log(`   - GET /api/uniswap/quote - Get swap quote with price impact`);
    console.log(`ðŸŒŠ Cetus endpoints (Sui Devnet):`);
    console.log(`   - GET /api/cetus/price/:pair - Get Cetus pool price (e.g., USDC-USDY)`);
    console.log(`   - POST /api/cetus/swap - Execute swap via Fusion+ or direct`);
    console.log(`   - GET /api/cetus/quote - Get Cetus swap quote`);
    console.log(`ðŸ”„ Enhanced arbitrage:`);
    console.log(`   - GET /api/arbitrage/celo-sui-enhanced - Cross-chain opportunities`);
    console.log(`ðŸ“ˆ Oracle endpoints:`);
    console.log(`   - GET /api/oracle/peg-status - Multi-chain monitoring`);
    console.log(`   - GET /api/oracle/chainlink/:pair?chain=ethereum - Single pair check`);
    console.log(`   - POST /api/oracle/peg-controls - Manual controls`);
    console.log(`ðŸŽ¯ Test commands:`);
    console.log(`   curl "http://localhost:${PORT}/api/uniswap/price/cUSD-USDC"`);
    console.log(`   curl "http://localhost:${PORT}/api/cetus/price/USDC-USDY"`);
    console.log(`   curl "http://localhost:${PORT}/api/arbitrage/celo-sui-enhanced"`);
    console.log(`ðŸ’¡ Using live DEX data: Uniswap V3 (${uniswapContracts.type}), Cetus (${cetusContracts.type})`);
  });
}

startServer().catch(console.error););
    console.log(`ðŸ“ˆ Swap endpoints:`);
    console.log(`   - POST /api/swap/bidirectional - Create atomic cross-chain swap`);
    console.log(`   - POST /api/swap/execute - Execute swap steps`);
    console.log(`   - GET /api/swap/status/:swapId - Check swap progress`);
    console.log(`   - POST /api/swap/refund - Refund expired swaps`);
    console.log(`ðŸ¦„ DEX endpoints:`);
    console.log(`   - GET /api/uniswap/price/:pair - Get pool price (e.g., cUSD-USDC)`);
    console.log(`   - GET /api/uniswap/pools/:pair - Compare all fee tiers`);
    console.log(`   - POST /api/uniswap/swap - Execute swap via Fusion+ or direct`);
    console.log(`   - GET /api/uniswap/quote - Get swap quote with price impact`);
    console.log(`ðŸ“ˆ Oracle endpoints:`);
    console.log(`   - GET /api/oracle/peg-status - Multi-chain monitoring`);
    console.log(`   - GET /api/oracle/chainlink/:pair?chain=ethereum - Single pair check`);
    console.log(`   - POST /api/oracle/peg-controls - Manual controls`);
    console.log(`ðŸŽ¯ Test commands:`);
    console.log(`   curl "http://localhost:${PORT}/api/uniswap/price/cUSD-USDC"`);
    console.log(`   curl "http://localhost:${PORT}/api/uniswap/quote?tokenIn=cUSD&tokenOut=USDC&amountIn=100"`);
    console.log(`ðŸ’¡ Using ${uniswapContracts.type === 'mock' ? 'mock data for development' : 'live DEX data'}`);
  });
}

startServer().catch(console.error);