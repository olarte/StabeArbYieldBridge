// Enhanced cross-chain spread analysis for Ethereum-Sui
async function analyzeCrossChainSpread(fromChain, toChain, fromToken, toToken, minSpread) {
  try {
    console.log(`ðŸ“Š Analyzing spread: ${fromChain}(${fromToken}) â†’ ${toChain}(${toToken})`);
    
    let ethereumPrice, suiPrice;
    
    // Get Ethereum price (Uniswap V3)
    if (fromChain === 'ethereum') {
      ethereumPrice = await getUniswapV3PriceOnSepolia(fromToken, 'USDC');
    } else {
      ethereumPrice = await getUniswapV3PriceOnSepolia('USDC', toToken);
    }
    
    // Get Sui price (Cetus)
    if (toChain === 'sui') {
      suiPrice = await getCetusPoolPrice('USDC', toToken);
    } else {
      suiPrice = await getCetusPoolPrice(fromToken, 'USDC');
    }
    
    // Calculate cross-chain spread
    const priceDiff = Math.abs(ethereumPrice - suiPrice);
    const avgPrice = (ethereumPrice + suiPrice) / 2;
    const spread = (priceDiff / avgPrice) * 100;
    
    // Determine arbitrage direction
    const direction = ethereumPrice > suiPrice ? 'ETHEREUM_TO_SUI' : 'SUI_TO_ETHEREUM';
    const profitable = spread >= minSpread;
    
    // Calculate estimated profit
    let estimatedProfit = 0;
    if (profitable) {
      const betterPrice = Math.max(ethereumPrice, suiPrice);
      const worsePrice = Math.min(ethereumPrice, suiPrice);
      estimatedProfit = ((betterPrice - worsePrice) / worsePrice) * 100;
    }
    
    return {
      ethereumPrice,
      suiPrice,
      spread: parseFloat(spread.toFixed(4)),
      direction,
      profitable,
      estimatedProfit: estimatedProfit.toFixed(2),
      minSpreadRequired: minSpread,
      timestamp: new Date().toISOString(),
      analysis: {
        priceDifference: priceDiff,
        averagePrice: avgPrice,
        betterChain: ethereumPrice > suiPrice ? 'ethereum' : 'sui'
      }
    };
    
  } catch (error) {
    console.error('Cross-chain spread analysis error:', error);
    return {
      ethereumPrice: 1.0,
      suiPrice: 1.0,
      spread: 0,
      profitable: false,
      error: error.message
    };
  }
}

// Get Uniswap V3 price on Sepolia
async function getUniswapV3PriceOnSepolia(tokenA, tokenB) {
  try {
    if (uniswapContracts.type.includes('uniswap_v3_sepolia')) {
      const tokenAAddress = CHAIN_CONFIG.ethereum.tokens[tokenA];
      const tokenBAddress = CHAIN_CONFIG.ethereum.tokens[tokenB];
      
      const poolAddress = await uniswapContracts.factory.getPool(tokenAAddress, tokenBAddress, 3000);
      if (poolAddress === ethers.ZeroAddress) {
        throw new Error(`Pool ${tokenA}/${tokenB} not found on Sepolia`);
      }

      const poolContract = new ethers.Contract(poolAddress, UNISWAP_V3_ABIS.Pool, ethProvider);
      const slot0 = await poolContract.slot0();
      
      const price = calculatePriceFromSqrtPriceX96(
        slot0.sqrtPriceX96, 
        await poolContract.token0(), 
        await poolContract.token1(),
        tokenAAddress, 
        tokenBAddress
      );
      
      return price.price0;
    }
    
    // Fallback to mock
    return getMockPrice(tokenA, tokenB);
  } catch (error) {
    console.error(`Sepolia ${tokenA}/${tokenB} price error:`, error);
    return getMockPrice(tokenA, tokenB);
  }
}